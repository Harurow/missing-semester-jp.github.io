---
layout: lecture
title: "雑録"
date: 2020-01-29
ready: true
video:
  aspect: 56.25
  id: JZDt-PRq0uo
---

## 目次

- [キーボード割り当て変更](#キーボード割り当て変更)
- [デーモン](#デーモン)
- [FUSE](#fuse)
- [バックアップ](#バックアップ)
- [API](#api)
- [一般的なコマンドラインのフラグとパターン](#一般的なコマンドラインのフラグとパターン)
- [ウィンドウマネージャ](#ウィンドウマネージャ)
- [VPN](#vpn)
- [Markdown](#markdown)
- [Hammerspoon (macOS用のデスクトップ操作自動化ツール)](#hammerspoon-macos用のデスクトップ操作自動化ツール)
- [ブート + Live USB](#ブート--live-usb)
- [Docker, Vagrant, 仮想マシン, クラウド, OpenStack](#docker-vagrant-仮想マシン-クラウド-openstack)
- [ノートブック型プログラミング環境](#ノートブック型プログラミング環境)
- [GitHub](#github)

## キーボード割り当て変更

プログラマにとって、キーボードは主要な入力方法です。コンピュータについて様々なカスタマイズができるように、キーボードについても様々な設定ができます。（そして、それには設定する価値があります。）

最も基本的な変更は、キーボードのキー割り当てを変更することです。
この変更は、通常、あるキーが押されるたびに、このイベントに割り込み、別のキーに対応する別のイベントに置き換えます。例を以下に示します。
- Caps LockをCtrlやEscapeに割り当て変更します。Caps Lockは非常に便利な位置にありますが、ほとんど使われていないので、私たち（インストラクター）はこの設定を強く推奨します。
- PrtScを音楽の再生/一時停止キーに割り当て変更します。ほとんどのOSは再生/一時停止キーの機能を持っています。
- CtrlとMeta（WindowsまたはCommand）を入れ替えます。

また、キーを任意のコマンドに対応付けることもできます。これは、頻繁に行うタスクを実行させたい時に便利です。ここでは、何らかのソフトウェアが特定のキーの組み合わせを待ち受け、その入力イベントが検出されるたびに何らかのスクリプトを実行します。
- 新しいターミナルやブラウザのウィンドウを開く。
- 長いメールアドレスやMITのID番号など、特定のテキストを入力する。
- コンピュータやディスプレイをスリープ状態にする。

さらに複雑な割り当て変更も可能です。
- 連続したキー入力の割り当てを変更できます。例えば、Shiftを5回押すとCaps Lockがトグルされる、といったように設定できます。
- キーの「タップ」（押し離し）と「ホールド」（押しっぱなし）で割り当てを変更できます。例えば、Caps Lockを素早くタップするとEscに割り当てられ、ホールドして修飾キーとして使用するとCtrlに割り当てられる、といったことができます。
- キーボードやソフトウェア固有の割り当て変更設定を持つこと。

このトピックを開始するためのいくつかのソフトウェアリソースを紹介します。
- macOS - [karabiner-elements](https://pqrs.org/osx/karabiner/), [skhd](https://github.com/koekeishiya/skhd), [BetterTouchTool](https://folivora.ai/)
- Linux - [xmodmap](https://wiki.archlinux.org/index.php/Xmodmap), [Autokey](https://github.com/autokey/autokey)
- Windows - コントロールパネル, [AutoHotkey](https://www.autohotkey.com/), [SharpKeys](https://www.randyrants.com/category/sharpkeys/)
- QMK - キーボードがカスタムファームウェアをサポートしている場合は、[QMK](https://docs.qmk.fm/)を使ってキーボードのハードウェア自体を設定し、そのキーボードを使用しているどのマシンでも割り当て変更を動作するようにできます。

## デーモン

デーモンという言葉は新しい言葉のように感じるかもしれませんが、あなたはすでにデーモンという概念になじんでいるでしょう。
ほとんどのコンピュータには、ユーザが起動して操作するのを待つのではなく、常にバックグラウンドで実行されている一連のプロセスがあります。
これらのプロセスはデーモンと呼ばれ、デーモンとして実行されるプログラムは、そのことを示すために `d` で終わることが多いです。
例えば、SSHデーモンである `sshd` は SSHのリクエストを待ち受けて、リモートユーザがログインに必要な資格を持っているかどうかを確認するプログラムです。

Linuxでは、`systemd`（システムデーモン）がデーモンプロセスを実行、設定するための最も一般的な方法です。
現在実行中のデーモンを一覧表示するために `systemctl status` を実行することができます。
ほとんどのデーモンはなじみがないように感じるかもしれませんが、ネットワークの管理、DNSクエリの解決、GUIの表示など、システムのコア部分を担当しています。
Systemd は `enable`, `disable`, `start`, `stop`, `restart`, あるいはサービスの `status` をチェックするために `systemctl` コマンドとやりとりをすることができます（これらは `systemctl` コマンドです）。

さらに興味深いことに、`systemd` は新しいデーモン（またはサービス）を設定し、有効にするための、とても扱いやすいインタフェースを持っています。
以下はシンプルなPythonアプリケーションを実行するためのデーモンの例です。
詳細は省略しますが、ほとんどのフィールドは自己説明的なものです。

```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Custom App
After=network.target

[Service]
User=foo
Group=foo
WorkingDirectory=/home/foo/projects/mydaemon
ExecStart=/usr/bin/local/python3.7 app.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

また、特定の頻度でプログラムを実行したいだけならば、独自にデーモンを構築する必要はなく、システムがすでに実行しているデーモンである [`cron`](https://www.man7.org/linux/man-pages/man8/cron.8.html) を使うことで、スケジューリングされたタスクを実行することができます。

## FUSE
現代のソフトウェアシステムは通常、小さなブロック構造を組み合わせて構成されています。
オペレーティングシステムには、ファイルシステムがどのような操作をサポートするかという共通規格があるため、異なるファイルシステムのバックエンドの使用がサポートされます。
例えば、ファイルを作成するために `touch` を実行すると、`touch` はそのファイルの作成のためにカーネルにシステムコールを発行し、カーネルは適切なファイルシステムコールを発行して指定されたファイルを作成します。
注意点として、UNIXファイルシステムは伝統的にカーネルモジュールとして実装されており、カーネルのみがファイルシステムコールの発行を許されているということです。

[FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) (Filesystem in User Space) を使うと、ファイルシステムをユーザプログラムで実装することができます。
ユーザはファイルシステムコールのためにユーザ空間のコードを実行し、FUSEは必要なシステムコールをカーネルインタフェースへと「橋渡し」します。
これは事実上、ユーザがファイルシステムコールに対して任意の機能を実装できることを意味します。

例えば、FUSEを使うと、仮想ファイルシステムで操作を実行するときはいつでも、その操作をSSH経由でリモートマシンに転送し、そこで実行し、その出力を自分に返すことができます。
このようにして、ローカルのプログラムは、実際にはリモートサーバにあるファイルを、あたかも自分のコンピュータにあるかのように扱えます。
これは実質的に `sshfs` が行っていることです。

FUSEファイルシステムの興味深い例をいくつか紹介します。
- [sshfs](https://github.com/libfuse/sshfs) - SSH経由のリモートファイル/フォルダをローカルで開きます。
- [rclone](https://rclone.org/commands/rclone_mount/) - DropboxやGoogle Drive、Amazon S3やGoogle Cloud Storageなどのクラウドストレージサービスをマウントして、ローカルでデータを開きます。
- [gocryptfs](https://nuetzlich.net/gocryptfs/) - 暗号化オーバーレイファイルシステムです。ファイルは暗号化されて保存されますが、ファイルシステムがマウントされるとマウントポイントではプレーンテキストとして表示されます。
- [kbfs](https://keybase.io/docs/kbfs) - End-to-endで暗号化された分散ファイルシステムです。個人フォルダ、共有フォルダ、パブリックフォルダを持つことができます。
- [borgbackup](https://borgbackup.readthedocs.io/en/stable/usage/mount.html) - データ重複除去、圧縮、暗号化されたバックアップをマウントして、簡単に参照できるようにします。

## バックアップ

バックアップされていないデータは、いつか永遠に消えてしまうかもしれません。
データをコピーするのは簡単ですが、データを確実にバックアップするのは難しいものです。
ここでは、バックアップの基本的な方法と、いくつかのアプローチの落とし穴について説明します。

まず、同じディスク内でデータをコピーすることはバックアップとは言えません。なぜなら、ディスクはすべてのデータの単一障害点だからです。
同様に、自宅の外付けドライブも、火事や強盗などで失われる可能性があるため、バックアップ手段としては不十分です。むしろ、オフサイトでバックアップをとることをお勧めします。

オンラインストレージでの同期もバックアップではありません。例えば、DropboxやGDriveは便利な手段ですが、データが消去されたり破損したりすると、その変更が伝播してしまいます。
同じ理由で、RAIDのようなディスクのミラーリングもバックアップではありません。データが削除されたり、破損したり、ランサムウェアで暗号化されたりした時に役に立たないからです。

優れたバックアップ手段の中核となる機能は、バージョン管理、重複排除、セキュリティです。
バージョン管理されたバックアップでは、変更履歴にアクセスして効率的にファイルを復元することができます。
効率的なバックアップ手段は、データの重複排除を使用することで増分の変更のみを保存し、ストレージのオーバーヘッドを削減します。
セキュリティに関しては、データを読み取ったり、さらに重要なこととして、すべてのデータや関連するバックアップを削除したりするために、他人が何を知っていたり持っていたりする必要があるのかを点検すべきです。
最後に、バックアップを盲目的に信用するのはよくない考えで、バックアップを使ってデータを復旧できるかどうかを定期的に確認する必要があります。

バックアップは、コンピュータ内のローカルファイルだけに留まりません。
ウェブアプリケーションの大幅な増加に伴い、大量のデータがクラウドに保存されるようになりました。
例えば、ウェブメール、ソーシャルメディアの写真、ストリーミングサービスの音楽プレイリスト、オンラインドキュメントなどは、対応するアカウントにアクセスできなくなると消えてしまいます。
このような情報のオフラインコピーを持つことが望ましく、これらのデータを取得して保存するために有志が作ったオンラインツールが提供されています。

より詳しい説明は、2019年の講義ノート [バックアップ](/2019/backups) を見てみてください。

## API

この授業では、コンピュータをより効率的に使って _ローカル_ なタスクをこなすことについて多くのことを説明してきましたが、これらの学びの多くは、より広いインターネットにも当てはまることがわかります。
インターネット上のほとんどのサービスは、そのデータにプログラムでアクセスできる「API」を持っています。
例えば、アメリカ政府は天気予報を取得するためのAPIを持っており、これを使えば自分のシェルで簡単に天気予報を取得することができます。

これらのAPIのほとんどは、似たフォーマットを持っています。
APIは構造化されたURLであり、多くの場合、`api.service.com`をルートとしており、パスとクエリパラメータは、読みたいデータや実行したいアクションを示します。
例えば、米国の気象データの場合、特定の場所の予報を取得するには、https://api.weather.gov/points/42.3604,-71.094 に GET リクエスト（例えば `curl`を使用）を発行します。
レスポンス自体には、その地域の特定の予報を得ることができる他のURLのまとまりが含まれています。
通常、レスポンスはJSONとしてフォーマットされており、これを[`jq`](https://stedolan.github.io/jq/)のようなツールに通すことで、関心のある情報に変換することができます。

APIによっては認証が必要なものがありますが、この認証は通常ある種の秘密の _トークン_ が用いられ、これをリクエストに含める必要があります。
APIのドキュメントを読んで、探している特定のサービスが何を使用しているかを確認する必要がありますが、「[OAuth](https://www.oauth.com/)」はよく使われるプロトコルです。
本質的には、OAuthは特定のサービスで「自分のように振る舞う」ことができるトークンを与え、特定の目的のためにのみ使用できるようにする方法です。
このトークンは _秘密_ のものであり、あなたのトークンにアクセスした人は、 _あなたの_ アカウントでトークンが許可したことは何でもできるということを覚えておいてください。

[IFTTT](https://ifttt.com/)は、APIのアイデアを中心としたウェブサイトとサービスです。膨大な数のサービスとの統合を提供し、それらのサービスからほぼ任意の方法でイベントを連鎖させることができます。
ぜひ一度見てみてください。

## 一般的なコマンドラインのフラグとパターン

コマンドラインツールには様々な種類があるため、使用する前にそれぞれの `man` ページを確認することを推奨します。
しかし、これらのツールには共通の機能がありますので、知っておくとよいでしょう。

 - ほとんどのツールは、そのツールの簡単な使用方法を表示するために、何らかの `--help` フラグをサポートしています。
 - 取り返しのつかない変更を引き起こすツールの多くは、「ドライラン」という概念をサポートしています。これは、 _実行されたであろう_ 内容を出力するだけで、実際に変更を実行するわけではありません。同様に、破壊的なアクションを行うたびにプロンプトが表示される「インタラクティブ」フラグを備えていることも多いです。
 - 通常、 `--version` または `-V` を使用して、プログラムに自身のバージョンを表示させることができます（バグを報告するのに便利です！）。
 - ほとんどのツールには、より詳細な出力を得るための `--verbose` または `-v` フラグがあります。通常、このフラグを複数回（ `-vvv` ）含めることでより _詳細な_ 出力を得ることができ、これはデバッグの際に便利です。同様に、多くのツールには `--quiet` フラグがあり、エラー時にのみ何かを表示するように設定できます。
 - 多くのツールでは、ファイル名の代わりに `-` を付けると、引数に応じて「標準入力」または「標準出力」を意味します。
 - 破壊的変更を行う可能性のあるツールは、一般的にデフォルトでは再帰的ではありませんが、再帰的にするための「リカーシブ」フラグ（多くの場合、 `-r` ）をサポートしています。
 - フラグのように _見える_ ものを通常の引数として渡したい場合があります。例えば、 `-r` というファイルを削除したいとします。また、 `ssh machine foo` のように、あるプログラムを別のプログラムに「通して」実行したいときに、「内側」のプログラム（ `foo` ）にフラグを渡したいとします。特別な引数 `--` は、プログラムが以下のフラグやオプション（ `-` で始まるもの）の処理を _停止_ させ、フラグのように見えるものをフラグとして解釈せずに渡すことができます。つまり、 `rm -- -r` や `ssh machine --for-ssh -- foo --for-foo` のように、フラグのように見えるものをフラグと解釈されずに渡すことができます。

## ウィンドウマネージャ

多くの人は、WindowsやmacOS、Ubuntuにデフォルトで搭載されているような「ドラッグ＆ドロップ」式のウィンドウマネージャを使い慣れているでしょう。
ウィンドウは画面上にただ単に散らばっており、それらをドラッグしてサイズを変えたり、重ね合わせたりすることができます。
しかし、これは「フローティング」ウィンドウマネージャと呼ばれるウィンドウマネージャの1つの _種類_ に過ぎません。
特にLinuxでは、他にもたくさんの種類があります。
特によく使われるのは、「タイリング」ウィンドウマネージャです。
タイリングウィンドウマネージャでは、ウィンドウは決して重ならず、tmuxのペインのように画面上にタイル状に配置されます。
タイリングウィンドウマネージャでは、画面は常に開いているウィンドウで埋め尽くされ、何らかの _レイアウト_ に従って配置されます。
1つのウィンドウを開くと、それが画面全体を占めます。
次に別のウィンドウを開くと、元のウィンドウはそれに合わせて縮小されます（多くの場合、2/3と1/3のように）。
3つ目のウィンドウを開くと、他のウィンドウは新しいウィンドウに合わせて再び縮小します。
tmuxのペインと同じように、キーボードでこれらのタイル状のウィンドウを操作することができ、マウスを使わずにウィンドウのサイズを変更したり、移動させたりすることができます。
使ってみる価値はありそうですね！

## VPN

最近、VPNが流行していますが、それが[正当な理由](https://gist.github.com/joepie91/5a9909939e6ce7d09e29)であるかどうかは明らかではありません。
VPNが何をしてくれて、何をしてくれないのかを知っておく必要があります。
VPNは最良の場合では、インターネットに関する限り、 _実際のところ_ インターネットサービスプロバイダー (ISP) を変更する方法に過ぎません。
すべてのトラフィックは、あなたの「実際の」場所ではなく、VPNプロバイダーから来ているように見え、あなたが接続しているネットワークは、暗号化されたトラフィックだけを見ることができます。

これは魅力的に見えるかもしれませんが、VPNを使用する際に実際に行っていることは、あなたの信頼を現在のISPからVPNホスティング会社に移しているだけだということを覚えておいてください。
あなたのISPが見ることが _できた_ ものは、VPNプロバイダーが _代わりに_ 見ることになります。
もし、あなたがISP _よりも_ VPNプロバイダーを信頼しているのであればそれは成果ですが、そうでなければ、あなたが得たものは明らかではありません。
空港で暗号化されていない危険な公衆無線LANを利用している場合は、その接続をあまり信用していないかもしれませんが、自宅ではそのトレードオフはそれほど明確ではありません。

また、最近では、少なくとも機密性の高いトラフィックの多くは、HTTPSやTLSを通じて既に暗号化されていることを知っておくべきでしょう。
この場合、あなたが「悪い」ネットワークを利用しているかどうかは、通常はほとんど問題になりません。-- ネットワーク事業者は、あなたがどのサーバーと通信しているかを知るだけで、やり取りされているデータについては何も知りません。

前述の「最良の場合」という言葉に注目してください。
VPNプロバイダーがソフトウェアの設定を誤って、暗号化が弱くなったり、完全に無効になったりすることは、決して珍しいことではありません。
また、VPNプロバイダーの中には、悪意のある（あるいは、少なくともご都合主義の）会社もあり、あなたのトラフィックをすべて記録し、その情報を第三者に販売する可能性もあります。
悪いVPNプロバイダーを選ぶことは、そもそもVPNを使わないことよりも悪いことが多いのです。

ピンチの時には、MITが学生向けに[VPN](https://ist.mit.edu/vpn)を運営しているので、見てみる価値はあるかもしれません。
また、自分で構築するのであれば、[WireGuard](https://www.wireguard.com/)を検討してみてください。

## Markdown

キャリアの中で何らかの文章を書く機会は多いでしょう。
そして、そのテキストを簡単な方法でマークアップしたいと思うことがよくあります。
例えば、テキストを太字や斜体にしたり、ヘッダーやリンク、コードフラグメントを追加したいことがあります。
WordやLaTeXのような重いツールを持ち出す代わりに、軽量マークアップ言語[Markdown](https://commonmark.org/help/)の使用を検討してみてはいかがでしょう。
Markdownはすでに見たことがあるでしょうし、少なくともそのいくつかのバリエーションは見たことがあるでしょう。
そのサブセットは、Markdownという名前でなくても、ほとんどどこでも使用され、サポートされています。
Markdownの核心は、人々がプレーンテキスト文書を書くときにテキストをマークアップする方法をコード化しようとするものです。
強調 (*italics*) は、単語を `*` で囲むことで追加されます。
強い強調（**ボールド**）は `**` を使って加えられます。
`#` で始まる行は見出しです（`#`の数が小見出しのレベルです）。
`-` で始まる行は箇条書きリストの項目で、数字 + `.`で始まる行は番号付きリストの項目です。
バッククォートは、`コードフォント`で単語を表示するために使われ、コードブロックは、行を4つのスペースでインデントするか、3つのバッククォートで囲むことで入力できます。

    ```
    コードをここに書く
    ```

リンクを貼る場合は、`[name](url)` のように角括弧の中にリンク先の _テキスト_ を入れ、その直後にURLを括弧で囲みます。
Markdownは簡単に使い始めることができ、ほとんどどこでも使用することができます。
実際、この講義のレクチャーノートや他のすべての講義はMarkdownで書かれており、生のMarkdownを[ここ](https://raw.githubusercontent.com/missing-semester/missing-semester/master/_2020/potpourri.md)で見ることができます。

## Hammerspoon (macOS用のデスクトップ操作自動化ツール)

[Hammerspoon](https://www.hammerspoon.org/)は、macOS用のデスクトップ操作自動化フレームワークです。
OSに機能的につながるLuaスクリプトを書くことができ、キーボード/マウス、ウィンドウ、ディスプレイ、ファイルシステムなどを操作することができます。

Hammerspoonでできることの例をいくつか挙げます。

- ウィンドウを特定の場所に移動させるホットキーを割り当てる
- ウィンドウを自動的に特定のレイアウトで表示するメニューバーボタンの作成
- （無線LANネットワークを検出することで）研究室に到着したときにスピーカーをミュートする
- 友人の電源を誤って取ってしまった場合、警告を表示する

高いレベルでは、Hammerspoonはメニューボタンやキープレス、イベントに紐付けられた任意のLuaコードを実行することができ、Hammerspoonはシステムと対話するための広範なライブラリを提供しているので、基本的には何をするにも制限はありません。
多くの人がHammerspoonの設定を公開しているので、インターネットで検索すれば必要なものは大体見つかりますが、自分でゼロからコードを書くこともできます。

### 参考資料

- [Getting Started with Hammerspoon](https://www.hammerspoon.org/go/)
- [Sample configurations](https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations)
- [Anish's Hammerspoon config](https://github.com/anishathalye/dotfiles-local/tree/mac/hammerspoon)

## ブート + Live USB

マシンが起動すると、OSがロードされる前に、[BIOS](https://ja.wikipedia.org/wiki/Basic_Input/Output_System)/[UEFI](https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface)がシステムを初期化します。
このプロセスでは、特定のキーの組み合わせを押すことで、このレイヤーのソフトウェアを設定することができます。
例えば、コンピュータは起動中に「Press F9 to configure BIOS. Press F12 to enter boot menu.」のようなことを出力するでしょう。
BIOSメニューでは、あらゆる種類のハードウェア関連設定を変更することができます。
また、ブートメニューに入ると、ハードディスクの代わりに代替デバイスから起動することができます。

[Live USB](https://ja.wikipedia.org/wiki/Live_USB)とは、OSが入ったUSBメモリのことです。
OS（例：Linuxディストリビューション）をダウンロードして、フラッシュドライブに書き込むことで作成できます。
このプロセスは、単に `.iso` ファイルをディスクにコピーするよりも少し複雑です。
[UNetbootin](https://unetbootin.github.io/)のような、Live USBの作成に役立つツールもあります。
Live USBは様々な目的に役立ちます。
とりわけ、既存のOSの構造が壊れて起動しなくなった場合、Live USBを使ってデータを回復したり、OSを修正したりすることができます。

## Docker, Vagrant, 仮想マシン, クラウド, OpenStack

[仮想マシン](https://ja.wikipedia.org/wiki/%E4%BB%AE%E6%83%B3%E3%83%9E%E3%82%B7%E3%83%B3)やコンテナのようなそれと似たツールを使うと、OSを含むコンピュータシステム全体をエミュレートすることができます。
これは、テスト、開発、または実験（悪意のあるコードを実行するなど）のために隔離された環境を構築するのに便利です。

[Vagrant](https://www.vagrantup.com/)は、マシンの構成（OS、サービス、パッケージなど）をコードで記述し、単純な `vagrant up` で仮想マシンをインスタンス化することができるツールです。
[Docker](https://www.docker.com/)はコンセプト的には似ていますが、代わりにコンテナを使用します。

また、クラウド上で仮想マシンをレンタルすることもでき、これはすぐに利用できる良い方法です。

- サービスのホスティングに使用される、パブリックIPアドレスを持つ安価な常時稼働マシン
- 大容量のCPU、ディスク、RAM、場合によってはGPUも搭載したマシン
- 物理的に利用可能な台数よりも多くのマシン（課金は秒単位で行われることが多いため、短時間で大量のコンピュータを利用したい場合には、数分間で1000台のコンピュータをレンタルすることも可能です

人気のあるサービスとしては、[Amazon AWS](https://aws.amazon.com/)、[Google Cloud](https://cloud.google.com/)、[Microsoft Azure](https://azure.microsoft.com/)、[DigitalOcean](https://www.digitalocean.com/)などがあります。

MIT CSAILのメンバーであれば、[CSAIL OpenStack instance](https://tig.csail.mit.edu/shared-computing/open-stack/)を通じて、研究用の仮想マシンを無料で手に入れることができます。

## ノートブック型プログラミング環境

[ノートブック型プログラミング環境](https://en.wikipedia.org/wiki/Notebook_interface)は、ある種のインタラクティブな開発や実験的な開発を行うのにとても便利です。
おそらく現在最も人気のあるノートブックプログラミング環境は、Python（および他のいくつかの言語）用の[Jupyter](https://jupyter.org/)でしょう。
また、[Wolfram Mathematica](https://www.wolfram.com/mathematica/)は、数学指向のプログラミングを行うのに適したノートブック型プログラミング環境です。

## GitHub

[GitHub](https://github.com/)は、オープンソースソフトウェア開発のための最も人気のあるプラットフォームの1つです。
[vim](https://github.com/vim/vim)や[Hammerspoon](https://github.com/Hammerspoon/hammerspoon)など、このクラスで紹介したツールの多くはGitHubでホストされています。
毎日使うツールをより良くするために、オープンソースへの貢献を始めるのは簡単です。

GitHubでプロジェクトに貢献するには、主に2つの方法があります。

- [Issue](https://help.github.com/ja/github/managing-your-work-on-github/creating-an-issue)の作成。
これは、バグを報告したり、新しい機能をリクエストしたりするときに使います。
どちらもコードの読み書きを伴わないので、非常に簡単に行うことができます。
質の高いバグ報告は開発者にとって非常に価値のあるものです。
また、既存の議論にコメントすることも有益です。
- [プルリクエスト](https://help.github.com/ja/github/collaborating-with-issues-and-pull-requests/about-pull-requests)を通じてコードを提供する。
これは一般的に、Issueを作成するよりも複雑です。
GitHub上のリポジトリを[フォーク](https://docs.github.com/ja/github/getting-started-with-github/fork-a-repo)し、フォークをクローンして新しいブランチを作成し、いくつかの変更（バグの修正や機能の実装など）を行い、そのブランチをプッシュしてから[プルリクエストの作成](https://help.github.com/ja/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request)を行うことができます。
この後、一般的にはプロジェクトのメンテナとのやりとりがあり、メンテナはあなたのパッチに対するフィードバックをしてくれるでしょう。
最後に、すべてがうまくいけば、あなたのパッチは上流のリポジトリにマージされます。
大きなプロジェクトでは、コントリビューティングガイドや初心者向けのIssueが用意されていることが多く、中には初めてのコントリビューターがプロジェクトに慣れるのを助けるメンターシッププログラムを用意しているところもあります。
